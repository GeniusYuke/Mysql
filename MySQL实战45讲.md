## 1 基础架构：一条SQL查询语句是如何执行的？
大体来说，MySQL可以分为Server层和存储引擎层两部分
- Server层包括连接器、查询缓存、分析器、优化器、执行器，涵盖所有的内置函数，跨存储引擎的功能（存储过程、触发器、视图）
- 存储引擎层负责数据的存储和提取，支持InnoDB、MyISAM、Memory等多个引擎
### 连接器
连接命令一般是这么写的：
```
mysql -h$ip -P$port -u$user -p
```
### 查询缓存
**查询缓存往往弊大于利**
只要有对一个表的更新，表上的所有查询缓存都会清空。一般只有在静态表上适合使用缓存（比如系统配置表，长时间更新一次）。
### 分析器
先做“词法分析”；然后做“语法分析”；
### 优化器
在表里面有多个索引的时候，决定使用哪个索引；在有多表关联（join）的时候决定各个表的连接顺序。
```
select * from t1 join t2 using(ID) where t1.c=10 and t2.d =20;
```
既可以先从表一取出c=10的记录的ID值，再根据ID值关联到表二，再判断表二里面的d的值是否等于20；也可以。。。。
### 执行器
首先判断有没有权限，然后更具表的引擎去调用接口，查询表，返回结果集
### 课后题
如果表 T 中没有字段 k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？
**答：**分析器。Oracle会在分析阶段判断语句是否正确，表是否存在，列是否存在等。猜测MySQL也这样
## 2 日志系统：一条SQL更新语句是如何执行的？
### 重要的日志模块：redo log
**Write-Ahead Logging** 先写日志，再写磁盘。当有一条记录需要更新的时候，先会把记录写到redo log里面，更新内存，在空闲的时候把操作记录更新到磁盘里面。
即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。
### 重要的日志模块：binlog
redo log 是InnoDB引擎特有的日志，Server层的日志为binlog（归档日志）。
两种日志有以下三点不同：
1. redo log 是 InnoDB 引擎特有的；binlog是 MySQL 的 Server 层实现的，所有引擎都可以使用。
2. redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
3. redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。
### 两阶段提交
将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是"两阶段提交"。保证两份日志之间的逻辑一致。
### 课后题 
一天一备和一周一备的区别？
**答：**一天一备恢复时间更快，成本高，消耗更多存储空间
## 3 事务隔离：为什么你改变了我还看不见？
### 隔离性与隔离级别
- 读未提交：一个事务还没提交时，他做的变更就能被别的事务看到。
- 读提交：一个事务提交之后，他做的变更才能被别的事务看到。
- 可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。
- 串行化：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。出现读写锁冲突时，后续访问事务必须等前一个事务执行完成才能继续执行。
在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。
假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。
这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。
### 事务隔离的实现
在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。
**尽量不要使用长事务。**
长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。
### 事务的启动方式
1. 显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。
2. set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。
建议使用方法一，如果考虑多一次交互问题，可以使用commit work and chain语法
### 课后题
你现在知道了系统里面应该避免长事务，如果你是业务开发负责人同时也是数据库负责人，你会有什么方案来避免出现或者处理这种情况呢？
**答：**
